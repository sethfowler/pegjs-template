import PEG from 'pegjs';

import { AlternatingList } from './helpers/alternatingList.js';
import { assertExhaustive } from './helpers/exhaustive.js';

export type Parser<T> = PEG.GeneratedParser<T>;
export type SourceLocation = PEG.SourceLocation;

/** Context functions and metadata which are available in all PEG.js actions. */
export type ActionContext = {
  /** @returns the text matched by the current rule. */
  text(): string;

  /** @returns the source range matched by the current rule. */
  location(): SourceLocation;

  /** Throw an exception indicating that 'expected' was expected but not found. */
  expected(expected: string, location?: SourceLocation): never;

  /** Throw an exception with the error message 'message'. */
  error(message: string, location?: SourceLocation): never;

  /** Options passed to the parser. */
  options: Record<string, any>;
};

/**
 * A PEG.js semantic action.
 * @param context - Context functions and metadata; see {@link ActionContext}.
 * @param labels - Any number of arguments corresponding to labels in the
 * grammar. The names must match the labels exactly.
 * @returns the result of the semantic action.
 */
export type Action = (context: ActionContext, ...labels: any[]) => any;

/**
 * Expressions that can be interpolated into a PEG.js grammar using
 * {@link pegGrammar} or {@link pegPartialGrammar}.
 */
export type InterpolatableExpression =
  GenerateOptions |
  PartialGrammar |
  Action |
  string;

/**
 * A template string tag function that generates a PEG.js grammar and compiles
 * it into a parser.
 *
 * You can interpolate several different kinds of expressions:
 *   - Strings.
 *   - Semantic actions. These are functions of type {@link Action}.
 *   - Partial grammars generated by {@link pegPartialGrammar}.
 *   - Parser generation options generated by {@link pegGenerateOptions}.
 */
export function pegGrammar<T>(
  templateStrings: TemplateStringsArray,
  ...actions: InterpolatableExpression[]
): Parser<T> {
  const templateArguments = new AlternatingList([templateStrings, actions]);
  const components = buildComponents(templateArguments);

  const actionMap: { [name: string]: Action } = {};
  let generateOptions: PEG.IBuildOptions | undefined = undefined;
  let nextActionId = 0;
  let grammar = '';
  for (const component of components) {
    switch (component.kind) {
      case 'action': {
        // Concoct a name for this action so we can provide it to PEG.js via the
        // grammar context.
        const name = `action${nextActionId++}`;
        actionMap[name] = component.value;

        if (component.contextArg === '') {
          // As a special case, don't bother constructing the action context
          // object if the caller doesn't use it.
          grammar += `{
            return ${name}();
          }`;
        } else {
          grammar += `{
            const ${component.contextArg} = { text, location, expected, error, options };
            return ${name}(${component.args.join(',')});
          }`;
        }

        break;
      }

      case 'generateOptions': {
        if (generateOptions !== undefined) {
          throw new Error(`Grammar contains multiple GenerateOptions instances`);
        }
        generateOptions = component.value;
        break;
      }

      case 'text': {
        grammar += component.value;
        break;
      }

      default:
        assertExhaustive(component);
    }
  }

  // Build the options object for generate(). We need to merge our action map
  // into the grammar context.
  const options = { ...(generateOptions ?? {}) };
  options.output = 'parser';
  options.context = {
    ...(options.context ?? {}),
    ...actionMap,
  };

  // Generate the parser.
  return PEG.generate(grammar, options) as Parser<T>;
}

/**
 * A template string tag function that generates a partial PEG.js grammar. This
 * works just like {@link pegGrammar} except that, instead of generating a
 * parser, the result is a {@link PartialGrammar} that can be interpolated into
 * other grammars. This allows you to share code between grammars, or build more
 * complex grammars from simple building blocks.
 */
export function pegPartialGrammar(
  templateStrings: TemplateStringsArray,
  ...actions: InterpolatableExpression[]
): PartialGrammar {
  const templateArguments = new AlternatingList([templateStrings, actions]);
  return new PartialGrammar(buildComponents(templateArguments));
}

/** A wrapper type containing a partial PEG.js grammar. */
export class PartialGrammar {
  constructor(public readonly components: GrammarComponent[]) {
  }
}

/**
 * @param options - Options for PEG.js's generate() function.
 * @returns a {@link GenerateOptions} object that can be interpolated into a
 * grammar to customize the parser that will eventually be generated.
 */
export function pegGenerateOptions(options: PEG.IBuildOptions): GenerateOptions {
  return new GenerateOptions(options);
}

/** A wrapper type containing options for PEG.js's generate() function. */
export class GenerateOptions {
  constructor(public readonly options: PEG.IBuildOptions) {
  }
}

type GrammarComponent = {
  kind: 'action';
  value: Action;
  args: string[];
  contextArg: string;
} | {
  kind: 'generateOptions';
  value: PEG.IBuildOptions;
} | {
  kind: 'text';
  value: string;
};

/**
 * @param args - The tagged template arguments from {@link pegGrammar} or
 * {@link pegPartialGrammar}.
 * @returns an array of {@link GrammarComponent} objects describing how to build
 * a PEG.js grammar.
 */
function buildComponents(
  args: Iterable<InterpolatableExpression>
): GrammarComponent[] {
  const components: GrammarComponent[] = [];
  for (const value of args) {
    switch (typeof value) {
      case 'string': {
        components.push({ kind: 'text', value });
        break;
      }

      case 'object': {
        if (value instanceof PartialGrammar) {
          for (const component of value.components) {
            components.push(component);
          }
        } else if (value instanceof GenerateOptions) {
          components.push({ kind: 'generateOptions', value: value.options });
        } else {
          throw new Error(`Unexpected type of interpolated value: ${value}`);
        }
        break;
      }

      case 'function': {
        // Parse the source code of the action and extract the function arguments.
        // We'll use the same arguments at the call site in the generated grammar.
        const actionSource = value.toString();
        const matchFunctionArgs = actionSource.match(/\(([^)]*)\)/);
        if (!matchFunctionArgs) {
          throw new Error(`Couldn't determine function arguments: '${actionSource}'`);
        }

        const args = matchFunctionArgs[1].trim().split(',');
        const contextArg = args[0].trim();

        components.push({ kind: 'action', value, args, contextArg });
        break;
      }

      default:
        throw new Error(`Unexpected type of interpolated value: ${value}`);
    }
  }

  return components;
}
